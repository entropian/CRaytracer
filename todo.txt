Fix Russian roulette in photon emission.
calcCameraRay is slow
Sample direct and indirect illumination separately. Done, now fix it.
Cook-Torrance
Gotta rethink global variables.
After removing normals and tangent in smooth triangle, memory usage increases slightly over time during rendering.
Figure out how to load san miguel.
Optimize mesh loading
Try different number of primitives in each BVH node
what's the relationship between kd, ks and kr (and kt)?
add normal type to torus
set default background color in scene file
Combine light pointer and light type into a struct?
change some push function arguments to pointers?
Change it so that the image plane isn't totally reliant on fov as input.
the eventual image plane struct could have a samples pointer of its own.
Update the clean up section.



SSE BVH:
Try converting BVH to an array based representation?
Look into stack based traversal


Concerns:
Cache? Alignment?

Features:
each BVH node contains 4 bounding boxes instead of one
four child pointers and the three split axes are stored for each inner node
Construct a sorted index array for triangles?

Questions:
Not sure why the split axes are needed.
    Answer: Storing the split axes allows exploiting the spatial order of the boxes for a more efficient
    pruning using the sign of the ray direction during tree traversal. However, the advantaged gain by this compared to
    sorting by intersection distance is small. So perhaps I won't need to store the axes in the nodes.
The paper is big on storing leaf informations elsewhere and keeping the BVH small.
How to deal with different primitives
    1. One option is to split the leaf, so that each new leaf node only contains one type of primitive
SIMD triangle intersection -- is it worth the trouble?
     try testing by shooting rays at a bunch of triangles with no accelerator
     doesn't seem worth it right now, at least not at the level that I can get it to.


Changing
            for(int k = last_stored; k <= stored_photons; k++)
to
            for(int k = 0; k <= photon_map->max_photons + 1; k++)
gets rid of the bright spot, so the problem must be with photon_map->photons[max_photons + 1]?
that should exceed the size of the array, so I don't know wtf is going on yet.
The above is probably actually irrelevant.
The bright spots are fixed it seems. Changing the light's location doesn't change the bright spot's location
Try changing the number of samples

irradiance is usually low like .7 1.4 .48
in the bright spot, irradiance was about 8, 8, 8

with nphoton = 20, in irradianceEstimate, I found a photon with power 98, 10, 11
which shouldn't be, because every photon starts with power 40, 40, 40, and it should be non-increasing with every bounce.
Actually, photon power does increase based on survival probability.
Given that the bright spot is a circle and there is only one bright spot, there's probably a single rogue photon with
      super high power.

The rogue photon, what do we know?
    Same y and z coordinate.
    x coordinate oscillates
    at the upper edge of the box

Changing the number of photons from 50000 to 40000 didn't do anything.
Changing y coord from 490 to 400 doesn't changed the location of the bright spot
Seems to not happen in debug?
Turning off optimization in release actually produced two bright spots consistently
Turning off all optimizations in release seem to give a white bright spot in the middle.

Also, inspect reflected and bounce_count mroe closely.
